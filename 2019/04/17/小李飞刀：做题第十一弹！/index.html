<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Aloha | Gaga酱的奇思妙想</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="萌萌の嘎嘎">
  
  
  
  
  <meta name="description" content="小李飞刀！例无虚发！">
<meta name="keywords" content="leetcode,python">
<meta property="og:type" content="article">
<meta property="og:title" content="小李飞刀：做题第十一弹！">
<meta property="og:url" content="http://yoursite.com/2019/04/17/小李飞刀：做题第十一弹！/index.html">
<meta property="og:site_name" content="Gaga酱の奇思妙想">
<meta property="og:description" content="小李飞刀！例无虚发！">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/04/17/小李飞刀：做题第十一弹！/1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/17/小李飞刀：做题第十一弹！/2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/17/小李飞刀：做题第十一弹！/21.png">
<meta property="og:updated_time" content="2019-04-17T14:53:55.828Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小李飞刀：做题第十一弹！">
<meta name="twitter:description" content="小李飞刀！例无虚发！">
<meta name="twitter:image" content="http://yoursite.com/2019/04/17/小李飞刀：做题第十一弹！/1.png">
  
  <link rel="icon" href="/css/images/favicon.png">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h3 class="site-title">
            
              <a href="/" title="Gaga酱の奇思妙想" rel="home"> Gaga酱の奇思妙想 </a>
            
          </h3>
          
          
            <div class="site-description">深水静流</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/">冲鸭❤</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/archives">archives❤</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/categories">碎碎念的基本法❤</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/tags">tags❤</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/about">岁月如歌❤</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/books">阅❤</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/movies">影❤</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-小李飞刀：做题第十一弹！" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      小李飞刀：做题第十一弹！
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/04/17/小李飞刀：做题第十一弹！/" class="article-date">
	  <time datetime="2019-04-17T14:36:37.000Z" itemprop="datePublished">April 17, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/小李の放学后/">小李の放学后</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p></p>
<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近忙着调教新装备，没有及时的写题解，但是没有在偷懒没刷题喔~<br>来认真整理下最近做的题目~</p>
<p>之前考虑按<code>tag</code>来刷题，后来收到了推荐的<code>leetcode题解</code>，就根据上面的说明陆续刷题啦~<br>tag主要做了：数组、双指针<br>找时间要开始部署<code>gitbook</code>了，然后将题解部署到电子书上~</p>
<h4 id="认真做题的分割线"><a href="#认真做题的分割线" class="headerlink" title="认真做题的分割线"></a>认真做题的分割线</h4><h5 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h5><p><strong><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></strong><br><strong>难度：简单</strong><br>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回<code>-1</code>。</p>
<blockquote>
<p><strong>案例</strong>:<br>s = “leetcode”<br>返回 0.<br>s = “loveleetcode”,<br>返回 2.</p>
</blockquote>
<p><strong>我的题解：</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mapa = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> mapa:</span><br><span class="line">                mapa[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapa[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            a = s[j]</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> mapa <span class="keyword">and</span> mapa[a] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p><img src="1.png" alt></p>
<p><strong>我的思路：</strong><br>做两次循环，第一次循环用来做映射表，用hash表可以快速查询。<br>第二遍从头检查，在hash表中仅出现一次的字母，即最早不重复的字母。</p>
<h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><p><strong><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></strong><br><strong>难度：简单</strong><br>给定一个数组 nums，编写一个函数将所有<code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<blockquote>
<p><strong>案例</strong>:<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>返回 2.</p>
</blockquote>
<p><strong>我的题解：</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = len(nums)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span> nums[i] !=<span class="number">0</span>:</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j +=<span class="number">1</span></span><br><span class="line">        nums[j:l] = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l-j)]</span><br></pre></td></tr></table></figure></p>
<p><img src="2.png" alt></p>
<p><strong>我的思路：</strong><br>从头遍历数组，如果对应数组的值不为0，则利用慢指针，将非零项向前移动归并。<br>最后一个非零项对应的索引到数组的最后则被0包围了~</p>
<h5 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h5><p><strong><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></strong><br><strong>难度：简单</strong><br>给定一个包含<code>0, 1, 2, ..., n</code>中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<blockquote>
<p><strong>案例</strong>:<br>输入: [3,0,1]<br>输出: 2<br>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p>
</blockquote>
<p><strong>我的题解：</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        l =len(nums)</span><br><span class="line">        sum_a = (<span class="number">1</span>+l)*l/<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sum += i</span><br><span class="line">        <span class="keyword">return</span> sum_a - sum</span><br></pre></td></tr></table></figure></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">![](<span class="number">3.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">缺少的值 = 未缺失数的序列综合 - 当前的序列总和</span><br><span class="line"></span><br><span class="line">##### 第四题</span><br><span class="line">**[<span class="number">229.</span> 求众数 <span class="symbol">II</span>][<span class="number">4</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定一个大小为 n 的数组，找出其中所有出现超过<span class="string">`⌊ n/3 ⌋`</span>次的元素。</span><br><span class="line"></span><br><span class="line">说明: 要求算法的时间复杂度为<span class="string">`O(n)`</span>，空间复杂度为<span class="string">`O(1)`</span>。</span><br><span class="line">&gt; **案例**:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">3</span>]</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure>
<p>class Solution(object):<br>    def majorityElement(self, nums):<br>        “””<br>        :type nums: List[int]<br>        :rtype: List[int]<br>        “””<br>        a = dict()<br>        b = list()<br>        n = len(nums) / 3<br>        for i in nums:<br>            if i not in a:<br>                a[i] = 1<br>            else:<br>                a[i] += 1<br>        for j in a:<br>            if a[j] &gt; n:<br>                b.append(j)<br>        return b<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![](4.png)</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的思路：**</span></span><br><span class="line">同第一题的思路一致，两次循环，第一次检查每个数的重复情况。</span><br><span class="line">第二遍循环用于找出对应的值。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 第五题</span></span><br><span class="line"><span class="strong">**[101. 对称二叉树][5]**</span></span><br><span class="line"><span class="strong">**难度：简单**</span></span><br><span class="line">给定一个二叉树，检查它是否是镜像对称的。</span><br><span class="line">例如，二叉树<span class="code">`[1,2,2,3,4,4,3]`</span>是对称的。</span><br><span class="line">但是下面这个<span class="code">`[1,2,2,null,3,null,3]`</span>则不是镜像对称的:</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的题解：**</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Definition-for-a-binary-tree-node"><a href="#Definition-for-a-binary-tree-node" class="headerlink" title="Definition for a binary tree node."></a>Definition for a binary tree node.</h1><h1 id="class-TreeNode-object"><a href="#class-TreeNode-object" class="headerlink" title="class TreeNode(object):"></a>class TreeNode(object):</h1><h1 id="def-init-self-x"><a href="#def-init-self-x" class="headerlink" title="def init(self, x):"></a>def <strong>init</strong>(self, x):</h1><h1 id="self-val-x"><a href="#self-val-x" class="headerlink" title="self.val = x"></a>self.val = x</h1><h1 id="self-left-None"><a href="#self-left-None" class="headerlink" title="self.left = None"></a>self.left = None</h1><h1 id="self-right-None"><a href="#self-right-None" class="headerlink" title="self.right = None"></a>self.right = None</h1><p>class Solution(object):<br>    def isSymmetric(self, root):<br>        “””<br>        :type root: TreeNode<br>        :rtype: bool<br>        “””<br>        if not root:<br>            return True<br>        return self.isSame(root.left,root.right)</p>
<pre><code>def isSame(self,leftNode,rightNode):
    if leftNode == None:
        return rightNode == None
    if rightNode == None:
        return leftNode == None
    if rightNode.val == leftNode.val:
        return self.isSame(leftNode.left,rightNode.right) and self.isSame(leftNode.right,rightNode.left)
    return False
</code></pre><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![](<span class="number">5.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">使用`递归`的思路，跳出条件为，左右节点不一致，包括两者某一个为空的情况。</span><br><span class="line">当还存在下一级的左右节点的时候，就做递归进行查找。</span><br><span class="line"></span><br><span class="line">##### 第六题</span><br><span class="line">**[<span class="number">905.</span> 按奇偶排序数组][<span class="number">6</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定一个非负整数数组`A`，返回一个由`A`的所有偶数元素组成的数组，后面跟`A`的所有奇数元素。</span><br><span class="line">你可以返回满足此条件的任何数组作为答案。</span><br><span class="line">&gt; 示例：</span><br><span class="line">输入：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 也会被接受。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure>
<p>class Solution(object):<br>    def sortArrayByParity(self, A):<br>        “””<br>        :type A: List[int]<br>        :rtype: List[int]<br>        “””<br>        n = [0]*len(A)<br>        k = 0<br>        j = len(A) - 1<br>        for i in range(len(A)):<br>            if A[i] % 2 ==1: #奇数<br>                n[j] = A[i]<br>                j -= 1<br>            else:<br>                n[k] = A[i]<br>                k += 1<br>        return n<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">![](<span class="number">6.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">新建一个数组，然后头尾两个指针，分别用于指向偶数和奇数。</span><br><span class="line"></span><br><span class="line">##### 第七题</span><br><span class="line">**[<span class="number">832.</span> 翻转图像][<span class="number">7</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定一个二进制矩阵`A`，我们想先水平翻转图像，然后反转图像并返回结果。</span><br><span class="line">水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转`[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]`的结果是`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]`。</span><br><span class="line">反转图片的意思是图片中的`<span class="number">0</span>`全部被`<span class="number">1</span>`替换，`<span class="number">1</span>`全部被`<span class="number">0</span>`替换。例如，反转`[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]`的结果是`[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]`。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def flipAndInvertImage(self, A):<br>        “””<br>        :type A: List[List[int]]<br>        :rtype: List[List[int]]<br>        “””</p>
<pre><code>#逆序
return [[j ^ 1 for j in i[::-1]] for i in A]
</code></pre><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">![](<span class="number">7</span>.png)</span><br><span class="line">**我的思路：**</span><br><span class="line">python感觉有很多小作弊的方式，比如这题先进行了逆序，然后再进行了位运算。</span><br><span class="line">仅仅用了一行代码也是很奇特了。</span><br><span class="line"></span><br><span class="line">##### 第八题</span><br><span class="line">**[<span class="number">922</span>. 按奇偶排序数组 II][<span class="number">8</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定一个非负整数数组`A`，`A`中一半整数是奇数，一半整数是偶数。</span><br><span class="line">对数组进行排序，以便当`A[i]`为奇数时，`i`也是奇数；当`A[i]`为偶数时，`i`也是偶数。</span><br><span class="line">你可以返回任何满足上述条件的数组作为答案。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure>
<p>class Solution(object):<br>    def sortArrayByParityII(self, A):<br>        “””<br>        :type A: List[int]<br>        :rtype: List[int]<br>        “””<br>        count0 = 0<br>        count1 = 1<br>        re = []<br>        for i in A:<br>            if i%2 == 0:<br>                re.insert(count0, i)<br>                count0 += 2<br>            else:<br>                re.insert(count1, i)<br>                count1 += 2<br>        return re<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">![](<span class="number">8.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">适用两个指针，一个从<span class="number">0</span>开始，一个从<span class="number">1</span>开始，每次的步数为<span class="number">2</span>，对应放入奇数和偶数几颗。</span><br><span class="line"></span><br><span class="line">##### 第九题</span><br><span class="line">**[<span class="number">509.</span> 斐波那契数][<span class="number">9</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">斐波那契数，通常用`F(n)`表示，形成的序列称为斐波那契数列。该数列由`<span class="number">0</span>`和`<span class="number">1</span>`开始，后面的每一项数字都是前面两项数字的和。也就是：</span><br><span class="line"></span><br><span class="line"> &gt;F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">给定`N`，计算`F(N)`。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def fib(self, N):<br>        “””<br>        :type N: int<br>        :rtype: int<br>        “””<br>        if N == 0:return 0<br>        if N==1 or N == 2:return 1<br>        return (self.fib(N-1)+self.fib(N-2))<br><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">![](<span class="number">9</span>.png)</span><br><span class="line"></span><br><span class="line">**我的思路：**</span><br><span class="line">因为每一个数的构成，都是由前面的数的基础构成，所以用递归的思路去寻找递归栈。</span><br><span class="line">递归栈的跳出条件为：<span class="built_in">n</span>=<span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">##### 第十题</span><br><span class="line">**[<span class="number">561</span>. 数组拆分 I][<span class="number">10</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定长度为**<span class="number">2</span><span class="built_in">n</span>**的数组, 你的任务是将这些数分成 <span class="built_in">n</span> 对, 例如 (<span class="symbol">a1</span>, <span class="symbol">b1</span>), (<span class="symbol">a2</span>, <span class="symbol">b2</span>), ..., (an, bn) ，使得从<span class="number">1</span> 到 <span class="built_in">n</span> 的 <span class="built_in">min</span>(ai, bi) 总和最大。</span><br><span class="line"> &gt;输入<span class="symbol">:</span> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">&gt;输出<span class="symbol">:</span> <span class="number">4</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="built_in">n</span> 等于 <span class="number">2</span>, 最大总和为 <span class="number">4</span> = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">4</span>).</span><br><span class="line"></span><br><span class="line">**提示**<span class="symbol">:</span></span><br><span class="line"><span class="built_in">n</span> 是正整数,范围在 [<span class="number">1</span>, <span class="number">10000</span>].</span><br><span class="line">数组中的元素范围在 [-<span class="number">10000</span>, <span class="number">10000</span>].</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def arrayPairSum(self, nums):<br>        “””<br>        :type nums: List[int]<br>        :rtype: int<br>        “””<br>        nums.sort()<br>        return sum(nums[::2])<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](10.png)</span><br><span class="line"><span class="strong">**我的思路：**</span></span><br><span class="line">最大的算法，其实是排序后获取2个一组中最小的那个数，获得的总值最大。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 第十一题</span></span><br><span class="line"><span class="strong">**[867. 转置矩阵][11]**</span></span><br><span class="line"><span class="strong">**难度：简单**</span></span><br><span class="line">给定一个矩阵<span class="code">`A`</span>， 返回<span class="code">`A`</span>的转置矩阵。</span><br><span class="line">矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</span><br><span class="line"><span class="strong">**我的题解：**</span></span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def transpose(self, A):<br>        “””<br>        :type A: List[List[int]]<br>        :rtype: List[List[int]]<br>        “””<br>        return zip(*A)<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">![](<span class="number">11.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">zip()函数，打包为元组的列表。</span><br><span class="line">zip(*)返回二维矩阵。---&gt;解压</span><br><span class="line"></span><br><span class="line">##### 第十二题</span><br><span class="line">**[<span class="number">1002.</span> 查找常用字符][<span class="number">12</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定仅有小写字母组成的字符串数组 <span class="symbol">A</span>，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现<span class="string">`3`</span>次，但不是<span class="string">`4`</span>次，则需要在最终答案中包含该字符<span class="string">`3`</span>次。</span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line">**示例 <span class="number">1</span>：**</span><br><span class="line">&gt;输入：[<span class="string">"bella"</span>,<span class="string">"label"</span>,<span class="string">"roller"</span>]</span><br><span class="line">输出：[<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>]</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def commonChars(self, A):<br>        “””<br>        :type A: List[str]<br>        :rtype: List[str]<br>        “””<br>        tmp = list(A[0])<br>        for i in range(1,len(A)):<br>            tmp_list =list()<br>            for j in A[i]:<br>                if j in tmp:<br>                    index = tmp.index(j)<br>                    del tmp[index]<br>                    tmp_list.append(j)<br>            tmp = tmp_list<br>        return tmp<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">!<span class="string">[]</span>(<span class="number">12</span>.png)</span><br><span class="line">**我的思路：**</span><br><span class="line">最基础的思路是双重循环，外层数组要是遍历一维，内层主要是循环每个二维。</span><br><span class="line">最开始以a<span class="string">[0]</span>作为重复值的参考，如果比对过程中发现了重复的值，就记录下来，并因为考虑到参考值本身可能存在重复值，所以删除对应索引上的值，并根据记录下来的重复值，不断的遍历过程中，就减少，最终获得的就是正确值。</span><br><span class="line"></span><br><span class="line">##### 第十三题</span><br><span class="line">**<span class="string">[350. 两个数组的交集 II]</span><span class="string">[13]</span>**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br><span class="line"></span><br><span class="line">**示例 <span class="number">1</span>:**</span><br><span class="line">&gt;输入: nums1 = <span class="string">[1,2,2,1]</span>, nums2 = <span class="string">[2,2]</span></span><br><span class="line">输出: <span class="string">[2,2]</span></span><br><span class="line">输入: nums1 = <span class="string">[4,9,5]</span>, nums2 = <span class="string">[9,4,9,8,4]</span></span><br><span class="line">输出: <span class="string">[4,9]</span></span><br><span class="line"></span><br><span class="line">**说明：**</span><br><span class="line">输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</span><br><span class="line">我们可以不考虑输出结果的顺序。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def intersect(self, nums1, nums2):<br>        “””<br>        :type nums1: List[int]<br>        :type nums2: List[int]<br>        :rtype: List[int]<br>        “””<br>        l = list()<br>        for i in nums2:<br>            if i in nums1:<br>                index = nums1.index(i)<br>                del nums1[index]<br>                l.append(i)<br>        return l<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">!<span class="string">[]</span>(<span class="number">13</span>.png)</span><br><span class="line">**我的思路：**</span><br><span class="line">另外增加一个数组用于记录重复值，因为可能存在同个数组中重复值，所以需要删除对应的索引上的值。</span><br><span class="line"></span><br><span class="line">##### 第十四题</span><br><span class="line">**<span class="string">[349. 两个数组的交集]</span><span class="string">[14]</span>**</span><br><span class="line">**难度：简单**</span><br><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br><span class="line"></span><br><span class="line">**示例:**</span><br><span class="line">&gt;输入: nums1 = <span class="string">[1,2,2,1]</span>, nums2 = <span class="string">[2,2]</span></span><br><span class="line">输出: <span class="string">[2]</span></span><br><span class="line">输入: nums1 = <span class="string">[4,9,5]</span>, nums2 = <span class="string">[9,4,9,8,4]</span></span><br><span class="line">输出: <span class="string">[9,4]</span></span><br><span class="line"></span><br><span class="line">**说明:**</span><br><span class="line">输出结果中的每个元素一定是唯一的。</span><br><span class="line">我们可以不考虑输出结果的顺序。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def intersection(self, nums1, nums2):<br>        “””<br>        :type nums1: List[int]<br>        :type nums2: List[int]<br>        :rtype: List[int]<br>        “””<br>        l = dict()<br>        a = list()<br>        for i in nums2:<br>            if i in nums1:<br>                if i not in l:<br>                    l[i] = 1<br>        for key in l:<br>            a.append(key)<br>        return a<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">![](<span class="number">14.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">循环其中一个数组，并新建hash记录重复值。最后遍历hash表，得出最终结果。</span><br><span class="line"></span><br><span class="line">##### 第十五题</span><br><span class="line">**[<span class="number">566.</span> 重塑矩阵][<span class="number">15</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">在<span class="symbol">MATLAB</span>中，有一个非常有用的函数<span class="string">`reshape`</span>，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</span><br><span class="line">给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</span><br><span class="line">重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</span><br><span class="line">如果具有给定参数的<span class="string">`reshape`</span>操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</span><br><span class="line">**示例：**</span><br><span class="line">&gt;输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">1</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。新的矩阵是 <span class="number">1</span> * <span class="number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def matrixReshape(self, nums, r, c):<br>        “””<br>        :type nums: List[List[int]]<br>        :type r: int<br>        :type c: int<br>        :rtype: List[List[int]]<br>        “””<br>        l_a = len(nums)<br>        l_b = len(nums[0])<br>        if l_a<em>l_b != r</em>c:<br>            return nums<br>        if l_a == r:<br>            return nums<br>        list_a = list()<br>        list_b = list()<br>        count = 0<br>        for i in range(l_a):<br>            for j in range(l_b):<br>                list_b.append(nums[i][j])<br>                count += 1<br>                if count == c:<br>                    list_a.append(list_b)<br>                    list_b = list()<br>                    count = 0<br>        return list_a<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](15.png)</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的思路：**</span></span><br><span class="line">首先判断行数和列数是否和给出的值一致，乘积是否一致，用于判断是否是否直接输出结果或者是否可行。</span><br><span class="line">然后新建两个数组用于新建矩阵，遍历原有矩阵即可。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 第十六题</span></span><br><span class="line"><span class="strong">**[485. 最大连续1的个数][16]**</span></span><br><span class="line"><span class="strong">**难度：简单**</span></span><br><span class="line">给定一个二进制数组， 计算其中最大连续1的个数。</span><br><span class="line"></span><br><span class="line"><span class="strong">**示例 1:**</span></span><br><span class="line">&gt;输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是<span class="code">`3`</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**注意：**</span></span><br><span class="line">输入的数组只包含<span class="code">`0`</span>和<span class="code">`1`</span>。</span><br><span class="line">输入数组的长度是正整数，且不超过<span class="code">`10,000`</span>。</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的题解：**</span></span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def findMaxConsecutiveOnes(self, nums):<br>        “””<br>        :type nums: List[int]<br>        :rtype: int<br>        “””<br>        max_l = 0<br>        count = 0<br>        for i in nums:<br>            if i == 1 :<br>                count +=1<br>            else: ###遇到0<br>                if count &gt; max_l:<br>                    max_l = count<br>                count = 0<br>        if count &gt; max_l:<br>            max_l = count<br>        return max_l<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](16.png)</span><br><span class="line"><span class="strong">**我的思路：**</span></span><br><span class="line">使用动态规划的思路，记录每次的最大值并进行比对。最后输出最大值。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 第十七题</span></span><br><span class="line"><span class="strong">**[167. 两数之和 II - 输入有序数组][17]**</span></span><br><span class="line"><span class="strong">**难度：简单**</span></span><br><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</span><br><span class="line"></span><br><span class="line">函数应该返回这两个下标值<span class="code">`index1`</span> 和<span class="code">`index2`</span>，其中<span class="code">`index1`</span>必须小于<span class="code">`index2`</span>。</span><br><span class="line"></span><br><span class="line"><span class="strong">**说明:**</span></span><br><span class="line"><span class="bullet">- </span>返回的下标值（index1 和 index2）不是从零开始的。</span><br><span class="line"><span class="bullet">- </span>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br><span class="line"><span class="strong">**我的题解：**</span></span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def twoSum(self, numbers, target):<br>        “””<br>        :type numbers: List[int]<br>        :type target: int<br>        :rtype: List[int]<br>        “””<br>        l = len(numbers)<br>        i = 0<br>        j = l - 1<br>        l_a = list()<br>        while  i &lt; j:<br>            if numbers[i]+numbers[j] == target:<br>                l_a.append(i+1)<br>                l_a.append(j+1)<br>                return l_a<br>            elif numbers[i]+numbers[j] &gt; target:<br>                j -= 1<br>            else:<br>                i +=1<br>        return null<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](17.png)</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的思路：**</span></span><br><span class="line">使用头尾两个指针，当两者对应的值相加，当大于目标值的时候，则尾指针左移，当小于目标值得时候，则尾指针右移。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 第十八题</span></span><br><span class="line"><span class="strong">**[633. 平方数之和][18]**</span></span><br><span class="line"><span class="strong">**难度：简单**</span></span><br><span class="line">给定一个非负整数 c ，你要判断是否存在两个整数<span class="code">`a`</span>和<span class="code">`b`</span>，使得<span class="code">`a²`</span>+<span class="code">`b²`</span>= c。</span><br><span class="line"></span><br><span class="line"><span class="strong">**示例:**</span></span><br><span class="line">&gt;输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 <span class="bullet">* 1 + 2 *</span> 2 = 5</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的题解：**</span></span><br></pre></td></tr></table></figure></p>
<p>import math<br>class Solution(object):<br>    def judgeSquareSum(self, c):<br>        “””<br>        :type c: int<br>        :rtype: bool<br>        “””<br>        a = int(math.sqrt(c))<br>        b = 0<br>        while a &gt; b:<br>            if a<strong>2 + b</strong>2 == c:<br>                return True<br>            elif a<strong>2 + b</strong>2 &gt; c:<br>                a -= 1<br>            else:<br>                b += 1<br>        if a<strong>2 + b</strong>2 == c:<br>            return True<br>        else:<br>            return False<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">![](<span class="number">18.</span>png)</span><br><span class="line">**我的思路：**</span><br><span class="line">两个指针，一个从<span class="number">0</span>开始，一个从开方数开始，不断逼近，判定是否平方和为对应值。</span><br><span class="line"></span><br><span class="line">##### 第十九题</span><br><span class="line">**[<span class="number">345.</span> 反转字符串中的元音字母][<span class="number">19</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</span><br><span class="line">**示例:**</span><br><span class="line">&gt;输入: <span class="string">"hello"</span></span><br><span class="line">输出: <span class="string">"holle"</span></span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def reverseVowels(self, s):<br>        “””<br>        :type s: str<br>        :rtype: str<br>        “””<br>        y = [‘a’,’e’,’i’,’o’,’u’,’A’,’E’,’I’,’O’,’U’]<br>        p = 0<br>        q = len(s) - 1<br>        s = list(s)<br>        while p&lt;=q:<br>            if s[q] not in y and s[p] not in y:<br>                p += 1<br>                q -= 1<br>            elif s[p] in y and s[q] not in y:<br>                q -= 1<br>            elif s[q] in y and s[p] not in y:<br>                p += 1<br>            else:<br>                flag = s[q]<br>                s[q] = s[p]<br>                s[p] = flag<br>                p += 1<br>                q -= 1<br>        return ‘’.join(s)<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](19.png)</span><br><span class="line"><span class="strong">**我的思路：**</span></span><br><span class="line">使用自定义hash表，并使用双指针，不断逼近，当于到两者都是元音的时候，进行数值交换。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 第二十题</span></span><br><span class="line"><span class="strong">**[141. 环形链表][20]**</span></span><br><span class="line"><span class="strong">**难度：简单**</span></span><br><span class="line">给定一个链表，判断链表中是否有环。</span><br><span class="line">为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果<span class="code">`pos`</span>是<span class="code">`-1`</span>，则在该链表中没有环。</span><br><span class="line"></span><br><span class="line"><span class="strong">**我的题解：**</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Definition-for-singly-linked-list"><a href="#Definition-for-singly-linked-list" class="headerlink" title="Definition for singly-linked list."></a>Definition for singly-linked list.</h1><h1 id="class-ListNode-object"><a href="#class-ListNode-object" class="headerlink" title="class ListNode(object):"></a>class ListNode(object):</h1><h1 id="def-init-self-x-1"><a href="#def-init-self-x-1" class="headerlink" title="def init(self, x):"></a>def <strong>init</strong>(self, x):</h1><h1 id="self-val-x-1"><a href="#self-val-x-1" class="headerlink" title="self.val = x"></a>self.val = x</h1><h1 id="self-next-None"><a href="#self-next-None" class="headerlink" title="self.next = None"></a>self.next = None</h1><p>class Solution(object):<br>    def hasCycle(self, head):<br>        “””<br>        :type head: ListNode<br>        :rtype: bool<br>        “””<br>        if not head:<br>            return False<br>        l1 = head<br>        l2 = head.next<br>        while l1 and l2 and l2.next:<br>            if l1 == l2:<br>                return True<br>            l1 = l1.next<br>            l2 = l2.next.next<br>        return False<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">![](<span class="number">20.</span>png)</span><br><span class="line"></span><br><span class="line">**我的思路：**</span><br><span class="line">使用快慢两个指针，一个步数为<span class="number">1</span>，一个步数为<span class="number">2</span>，当存在环的时候，两者一定会相遇。</span><br><span class="line"></span><br><span class="line">##### 第二十一题</span><br><span class="line">**[<span class="number">985.</span> 查询后的偶数和][<span class="number">21</span>]**</span><br><span class="line">**难度：简单**</span><br><span class="line">给出一个整数数组`A`和一个查询数组`queries`。</span><br><span class="line">对于第`i`次查询，有val=queries[i][<span class="number">0</span>], index = queries[i][<span class="number">1</span>]，我们会把`val`加到`A[index]`上。然后，第`i`次查询的答案是`A`中偶数值的和。</span><br><span class="line">（此处给定的 index = queries[i][<span class="number">1</span>] 是从 <span class="number">0</span> 开始的索引，每次查询都会永久修改数组 A。）</span><br><span class="line">返回所有查询的答案。</span><br><span class="line">你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。</span><br><span class="line">**示例：**</span><br><span class="line">&gt;输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], queries = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-3</span>,<span class="number">1</span>],[<span class="number">-4</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">开始时，数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。</span><br><span class="line">将 <span class="number">1</span> 加到 A[<span class="number">0</span>] 上之后，数组为 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，偶数值之和为 <span class="number">2</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">8</span>。</span><br><span class="line">将 <span class="number">-3</span> 加到 A[<span class="number">1</span>] 上之后，数组为 [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">4</span>]，偶数值之和为 <span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span>。</span><br><span class="line">将 <span class="number">-4</span> 加到 A[<span class="number">0</span>] 上之后，数组为 [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">4</span>]，偶数值之和为 <span class="number">-2</span> + <span class="number">4</span> = <span class="number">2</span>。</span><br><span class="line">将 <span class="number">2</span> 加到 A[<span class="number">3</span>] 上之后，数组为 [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">6</span>]，偶数值之和为 <span class="number">-2</span> + <span class="number">6</span> = <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">**我的题解：**</span><br></pre></td></tr></table></figure></p>
<p>class Solution(object):<br>    def sumEvenAfterQueries(self, A, queries):<br>        “””<br>        :type A: List[int]<br>        :type queries: List[List[int]]<br>        :rtype: List[int]<br>        “””<br>        l =list()<br>        sum = 0<br>        sum_a = 0<br>        for j in A:<br>            if j%2 ==0:<br>                sum_a += j<br>        for i in range(len(queries)):<br>            A[queries<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">i</a>] += queries[i][0]#增加数值<br>            if A[queries<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">i</a>] % 2 ==0:#是偶数<br>                if queries[i][0]%2 ==0:#是偶数<br>                    sum = sum_a + queries[i][0]<br>                else:#是奇数<br>                    sum = sum_a +  A[queries<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">i</a>]<br>            else:#是奇数<br>                if queries[i][0]%2 ==0:#是偶数<br>                    sum = sum_a<br>                else:<br>                    sum = sum_a - A[queries<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">i</a>] + queries[i][0]<br>            l.append(sum)<br>            sum_a =sum<br>        return l<br><code>`</code></p>
<p><img src="21.png" alt><br><strong>我的思路</strong><br>每次比对前，比对所加数的奇偶，以及对应的数原有的奇偶。<br>当奇数+奇数，则总值加上俩奇数之和；当奇数+偶数，则总值不增加；当偶数加偶数，则总数增加新增值；当偶数+奇数，则总值减少原有偶数值。</p>
<h4 id="小小总结"><a href="#小小总结" class="headerlink" title="小小总结"></a>小小总结</h4><p>按tag来刷，会对对应思路有更为深刻的理解，小李要继续加油呀！</p>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/小李の放学后/">小李の放学后</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

      
        
	<div id="comment">
	
	<!-- 多说评论框 start -->
	 <div class="ds-thread" data-thread-key="/2019/04/17/小李飞刀：做题第十一弹！/" data-title="小李飞刀：做题第十一弹！" data-url="http://yoursite.com/2019/04/17/小李飞刀：做题第十一弹！/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"iTimeTraveler"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script>
	<!-- 多说公共JS代码 end -->
	
	</div>
	<link rel="stylesheet" href="/css/comment.css">


      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/04/14/Y想-190414/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Y想-190414</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#认真做题的分割线"><span class="nav-number">2.</span> <span class="nav-text">认真做题的分割线</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一题"><span class="nav-number">2.1.</span> <span class="nav-text">第一题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二题"><span class="nav-number">2.2.</span> <span class="nav-text">第二题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第三题"><span class="nav-number">2.3.</span> <span class="nav-text">第三题</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Definition-for-a-binary-tree-node"><span class="nav-number"></span> <span class="nav-text">Definition for a binary tree node.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#class-TreeNode-object"><span class="nav-number"></span> <span class="nav-text">class TreeNode(object):</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#def-init-self-x"><span class="nav-number"></span> <span class="nav-text">def init(self, x):</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-val-x"><span class="nav-number"></span> <span class="nav-text">self.val = x</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-left-None"><span class="nav-number"></span> <span class="nav-text">self.left = None</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-right-None"><span class="nav-number"></span> <span class="nav-text">self.right = None</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Definition-for-singly-linked-list"><span class="nav-number"></span> <span class="nav-text">Definition for singly-linked list.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#class-ListNode-object"><span class="nav-number"></span> <span class="nav-text">class ListNode(object):</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#def-init-self-x-1"><span class="nav-number"></span> <span class="nav-text">def init(self, x):</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-val-x-1"><span class="nav-number"></span> <span class="nav-text">self.val = x</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-next-None"><span class="nav-number"></span> <span class="nav-text">self.next = None</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小小总结"><span class="nav-number">1.</span> <span class="nav-text">小小总结</span></a></li></ol>
    
    </li></div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">冲鸭❤</a>
  
    <a href="/archives" class="mobile-nav-link">archives❤</a>
  
    <a href="/categories" class="mobile-nav-link">碎碎念的基本法❤</a>
  
    <a href="/tags" class="mobile-nav-link">Tags❤</a>
  
    <a href="/about" class="mobile-nav-link">岁月如歌❤</a>
  
    <a href="/books" class="mobile-nav-link">阅❤</a>
  
    <a href="/movies" class="mobile-nav-link">影❤</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Gaga酱の奇思妙想 All Rights Reserved.
        
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>














  <script type="text/javascript" src="js/love.js"></script>
  <script type="text/javascript" src="js/float.js"></script>
  <script type="text/javascript" src="js/typewriter.js"></script>
  <script type="text/javascript" color="0,104,183" opacity="1" zindex="-1" count="50" src="js/particle.js"></script>
  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
